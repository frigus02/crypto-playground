use super::super::analysis::hemming_distance;
use super::super::analysis::letter_frequency::{get_best_xor_score, get_en_letter_frequency_map};
use super::super::encoding::base64;
use super::super::encoding::xor;
use std::cmp;
use std::cmp::Ordering;

pub struct Info {
    pub key: Vec<u8>,
    pub plain_text: String,
}

pub fn run(base64: &str) -> Result<Info, String> {
    let en_letter_frequency_map = get_en_letter_frequency_map()
        .map_err(|err| format!("reading letter_frequency_en failed: {}", err))?;

    let bytes = base64::decode(base64);
    let bytes_len = bytes.len();

    let mut possible_key_sizes = (2..41)
        .into_iter()
        .map(|key_size| {
            get_average_normalized_hemming_distance(&bytes, key_size, 10)
                .map(|edit_distance| (key_size, edit_distance))
        }).collect::<Result<Vec<_>, _>>()?;
    possible_key_sizes.sort_by(|(_, edit_distance_a), (_, edit_distance_b)| {
        edit_distance_a
            .partial_cmp(edit_distance_b)
            .unwrap_or(Ordering::Greater)
    });

    let possible_keys: Vec<_> = possible_key_sizes
        .into_iter()
        .take(3)
        .filter_map(|(key_size, _)| {
            let blocks_len = (bytes_len as f64 / key_size as f64).ceil() as usize;
            let mut blocks = Vec::with_capacity(blocks_len);
            for i in 0..blocks_len {
                let block = &bytes[(i * key_size)..cmp::min((i + 1) * key_size, bytes_len - 1)];
                blocks.push(block);
            }

            let mut transposed_blocks = Vec::with_capacity(key_size);
            for i in 0..key_size {
                let mut transposed_block = Vec::with_capacity(blocks_len);
                for j in 0..blocks_len {
                    if i < blocks[j].len() {
                        transposed_block.push(blocks[j][i]);
                    }
                }

                transposed_blocks.push(transposed_block);
            }

            let scores: Result<Vec<_>, _> = transposed_blocks
                .iter()
                .map(|block| {
                    get_best_xor_score(&en_letter_frequency_map, block) //.map(|score| score.key)
                }).collect();

            scores
                .map(|scores| {
                    let key: Vec<_> = scores.iter().map(|score| score.key).collect();
                    let score_sum: f64 = scores.iter().map(|score| score.score).sum();

                    (key, score_sum / scores.len() as f64)
                }).ok()
        }).collect();

    for result in possible_keys {
        let key = result.0;
        let decoded_bytes = xor::encode(&bytes, &key);
        let decoded_key = String::from_utf8(key).unwrap();
        match String::from_utf8(decoded_bytes) {
            Ok(plain_text) => {
                println!("\n****\nKey: {} {}\n****\nText: {}\n", decoded_key, result.1, plain_text)
            }
            Err(err) => println!("\ndecoding failed: {}\n", err),
        };
    }

    let key = vec![1, 2, 3];
    let plain_text = String::from("hello");
    return Ok(Info { key, plain_text });
}

fn get_average_normalized_hemming_distance(
    bytes: &[u8],
    key_size: usize,
    chunks: usize,
) -> Result<f64, String> {
    let bytes_len = bytes.len();
    let normalized_edit_distances = (0..chunks)
        .into_iter()
        .filter_map(|no| {
            let first_index = no * 2 * key_size;
            let second_index = (no * 2 + 1) * key_size;
            let third_index = (no * 2 + 2) * key_size;
            if third_index < bytes_len {
                let first = &bytes[first_index..second_index];
                let second = &bytes[second_index..third_index];

                Some(
                    hemming_distance::get(first, second)
                        .map(|edit_distance| edit_distance as f64 / key_size as f64),
                )
            } else {
                None
            }
        }).collect::<Result<Vec<_>, _>>()?;

    let used_chunks = normalized_edit_distances.len();
    let sum = normalized_edit_distances.iter().sum::<f64>();

    return Ok(sum / used_chunks as f64);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn run_test() {
        let base64 = "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";
        let result = run(base64);
        assert!(result.is_ok());

        let info = result.unwrap();
        assert_eq!(vec![1, 2, 3], info.key);
        assert_eq!("test not implemented", info.plain_text);
    }
}
